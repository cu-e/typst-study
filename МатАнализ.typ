

#set heading(numbering: "1.")
#set text(size: 14pt)
#show outline.entry.where(
  level: 1
): it => {
  v(12pt, weak: true)
  strong(it)
}

//header
#page( footer:[#align(center, text(14pt)[2024г.])])[


  #align(center, text(17pt)[
    *Конспект по Математическому Анализу*
  ])
  #align(center, text(15pt)[
    *Торопов Егор Сергеевич*
  ])

  #align(center, text(14pt)[
    *Уральский Федеральный Университет*
  ])
  #align(center, text(14pt)[
    Прикладная математика
  ])

  #align(center, text(14pt)[
  *Выпуск:* '28
])

]

//Оглавление
#page()[
  #align(center, text(17pt)[
  *Математический Анализ*
])
#align(center)[
*Преподаватель:* \
Рекант Марк Александрович
]
#outline(
  title: "Оглавление",
  indent: auto
  )]

//Логика высказываней
#page()[
  #align(center)[
  = *Логика Высказываней*]
  Имеет только _Истенность_ и _Ложь_,
  не имеет недосказонастей!

#quote[
  Если в математики это не аксиома, то нуждается в докозательстве!
]\ \
 - Истина $A = 1$ \
 - Ложь $A = 0$

 _т.е В математике ложь это 0,а истина это 1!_


\
 == Операция конъюкция
_Обозначется как *$and$* или *&*_ 
\
/ #underline("Если") ---: $A and B = 1 <=> A = B = 1$ \ оба истенны
\
! Каждая операция соответствует таблице истенности
\
=== Таблица истенности

#table(columns: 3, align: center,
[$A$], [$B$], [$A and B$],
[1], [1], [1],
[1], [0], [0],
[0], [1], [0],
[0], [0], [0], )
Это бинарная таблица похожая на *умножение* 
\

=== Свойства
$A and I = A$ (т.к I это истина)
\
$A and L = L$ (т.к L это ложь) 
\
$A and A  = A$
\
$A and B = B and A$
\
$A and (B and C) = (A and B) and C$ (Ассациотивность), истенно только тогда когда все истенно



== Операция Дизъюнкция
_Обозначается как $or $ или_ *OR*

=== Таблица истенности

#table(columns: 3, align: center,
[$A$], [$B$], [$A or B$],
[1], [1], [1],
[1], [0], [1],
[0], [1], [1],
[0], [0], [0], )
Это бинарная таблица похожая на *сложение* 
\ 
=== Свойства
$A or I = I$ (т.к I это истина)
\
$A or L = A$ (т.к L это ложь) 
\
$A or B = B or A$ (коммутативность)
\
$A or (B or C) = (A or C) or B$

\
== Операция Отрицания
_Обозначается как $not$ или_ *not* 
\
$0 = not A <=> A = 1$

\
== Закон Де Моргана
$not(A and B) = not A or not B$ 
\
$not(A and B) = 0 <=> A  = B = 1 <=> A and B = 1$ 

\ 
$not (A or B) = not A and not B$
\
$not A or not B = 0 <=> A = B = 1$

#figure(
image("storage/image.png", width: 10cm), caption: "Закон Де Моргана",
)

== Операция Имплекации
_Обозначется как $=>$_
\
$underbrace("A => B", "Посылка => Следствие")$

=== Таблица Истенности
#table(columns: 3, align: center,
[ A ], [B], [$A => B$],
[1], [1], [1],
[1], [0], [0],
[0], [1], [1],
[0], [0], [1]
)
Это свойство служит доказательством от противного
Давайте отрицание применим к кванотору

$not(forall x in X (P(x)))$ - когда отрицание истенно?
\
Когда есть те ктогда не для всех икс  $ ( = exists x in X (P(x)))$ не справедливо, что означает, что существует такое отрицание $P(x) = not (P(x))$;

#quote()[
  При отрицании кванторов (), они заменяются на квантор (), а высказывание под кватнором отрицается
]
]



//Математическая логика
#page()[
#align(center)[
  = *Математическая логика*
]

/ *Предикат*:--- Это функция с множеством значений (Например множество $RR$ (Целых чисел)) которое возращает $0$ , если утверждение истинно, либо 0, если оно ложно.  например предикат $P(x, y)$\ $P:X→{0,1}$ где $X$ — это множество, откуда берутся значения переменных (например, множество целых чисел, вещественных чисел и т. д.), а результатом всегда будет либо 0, либо 1.
_т.е утверждает что-то о каждом элементе из X, возвращая 0 или 1 в зависимости от того, выполняется ли это утверждение для данного элемента._

*Пример* \
 у нас есть множество целых чисел $X = {1, 2, 3, 4, 5}$. Предикат $P(x)$, который проверяет, является ли число чётным, будет принимать отдельные числа из этого множества $X$ по одному.

- $P(1)$ возвращает $0$, так как $1$ нечётное.
- $P(2)$ возвращает $1$, так как $2$ чётное.
- $P(3)$ возвращает $0$, так как $3$ нечётное.

Таким образом, предикат **принимает один элемент** (например, $x = 1$ ) из множества $X$ и проверяет условие для этого элемента.

*Вывод*: Предикат работает с отдельными элементами множества, а не с самим множеством.  
]









